package engine;

import java.util.ArrayList;
import java.util.List;

import model.Graph;

/**
 * Generate graphs (currently) from numbers that represent 
 * 
 * @author maclean
 *
 */
public class PartitioningGenerator {

    /**
     * The key method for this class - generate all the structures that have
     * <code>totalValence</code> total valence, and <code>numberOfAtoms</code>
     * atoms and with a maximum valence of <code>maxValence</code>.
     * 
     * So, for a constitutional formula like 'C4H6', the total valence is
     * ((number of carbons) * (carbon valence)) - (number of hydrogens) =
     * (4 * 4) - 6 = 10. There are 4 carbon atoms, so the call would be:
     * 
     *   PartitioningGenerator.generate(10, 4, 4);
     *   
     * to get all the C4H6s.
     * 
     * @param totalValence
     * @param numberOfAtoms
     * @param maxValence
     * @return
     */
    public static List<Graph> generate(
            int totalValence, int numberOfAtoms, int maxValence) {

        List<Graph> graphs = new ArrayList<Graph>();
        Partition[] partitions = PartitionCalculator.partition(
                    totalValence, numberOfAtoms);
        
        for (Partition partition : partitions) {
            /* This line is necessary because the partition calculator will
             * make partitions like 10 = [7, 1, 1, 1] and '7' is too high a
             * valence
             */
            if (partition.getPart(0) > maxValence) continue;
            PartitioningGenerator.generateForPartition(partition, graphs);
        }

        return graphs;
    }

    /**
     * Add to the list of graphs all the graphs generated by this partition.
     * 
     * @param p the partition to make graphs from
     * @param graphs the list of graphs to add to
     */
    public static void generateForPartition(Partition p, List<Graph> graphs) {
        PartitioningGenerator.backtrack(p, graphs, 0, new Solution(p.size()));
    }
    
    /**
     * For a particular partition, make all the structures that correspond to
     * it.
     * 
     * @param p
     * @param graphs
     * @param partIndex
     * @param solution
     */
    private static void backtrack(
            Partition p, List<Graph> graphs, int partIndex, Solution solution) {
        
        if (PartitioningGenerator.isOkay(solution, p) ||
                partIndex >= p.size()) {
            PartitioningGenerator.backtrackGraph(
                    solution, new Graph("C", solution.size()), 0, graphs);
        } else {
            int part = p.getPart(partIndex);
            for (int[] subPartition : 
                PartitioningGenerator.getPossibleNextSubPartitions(part)) {
                PartitioningGenerator.backtrack(
                        p, 
                        graphs, 
                        partIndex + 1, 
                        solution.add(subPartition));
            }
        }
    }
    
    /**
     * Potentially check the solution for viability - at the moment, just
     * ensure that it is long enough.
     * 
     * @param solution
     * @param partition
     * @return
     */
    private static boolean isOkay(Solution solution, Partition partition) {
        return solution.size() == partition.size();
    }

    /**
     * Simple method to get all the sub-partitions for a particular part.
     * 
     * @param part
     * @return
     */
    private static List<int[]> getPossibleNextSubPartitions(int part) {
        List<int[]> subPartitions = new ArrayList<int[]>();
        for (int[] subPartition : Partition.basicPartitions[part]) {
            subPartitions.add(subPartition);
        }
        return subPartitions;
    }

    /**
     * For a 'solution' (a list of sub-partitions) 
     * 
     * @param solution
     * @param graph
     * @param i
     * @param gs
     */
    private static void backtrackGraph(
            Solution solution, Graph graph, int i, List<Graph> gs) {
        if (i == solution.size() - 1) {
            if (graph.inPartialOrder() && graph.fullyConnected()) {
                gs.add(graph);
            }
        } else {
            if (solution.hasSubPartsAt(i)) {
                int lastSubPart = -1;
                for (int x = 0; x < solution.sizeAt(i); x++) {
                    
                    // avoid duplicating graphs
                    if (solution.subPartAt(i, x) == lastSubPart) {
                        continue;
                    }
                    
                    int subPart = solution.subPartAt(i, x);
                    for (int j = i + 1; j < solution.size(); j++) {
                        
                        // check for existing bonds between these atoms
                        if (!graph.noArcBetween(i, j)) continue;
                        
                        // try to find a matching half-bond
                        int k = solution.indexOf(subPart, j);
                        if (k == -1) continue;
                        
                        Graph graphCopy = new Graph(graph);
                        graphCopy.addArc(i, j, subPart);
                        
                        Solution solutionCopy = new Solution(solution);
                        solutionCopy.remove(i, x);
                        solutionCopy.remove(j, k);
                        
                        backtrackGraph(solutionCopy, graphCopy, i, gs);
                    }
                    lastSubPart = subPart;
                }
            } else {
                // no more half-bonds to connect at this atom 
                backtrackGraph(
                        new Solution(solution), new Graph(graph), i + 1, gs);
            }
        }
    }

    public static void main(String[] args) {
        int valence = Integer.parseInt(args[0]);
        int numberOfAtoms = Integer.parseInt(args[1]);
        int maxValence = Integer.parseInt(args[2]);
        for (Graph g : PartitioningGenerator.generate(
                valence, numberOfAtoms, maxValence)) {
            System.out.println(g);
        }
    }
}
